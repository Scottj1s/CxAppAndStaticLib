// This replaces the DLL export TU and WinRT activation TU from vccorlib (CX CRT support),
// allowing hooking activation of types from a referenced C++/WinRT static library, both
// externally via DllGetActivationFactory and internally via __getActivationFactoryByPCWSTR.

#include "pch.h"
#include <string_view>
#include <wrl.h>

using namespace std::literals;

// Generated by cppwinrt -opt in class.g.cpp, declared here to avoid including the C++/WinRT generated headers.
void* winrt_make_CxComponent_StaticLibrary2_Class2();
void* winrt_make_CxComponent_StaticLibrary2_XamlMetaDataProvider();

namespace Platform {
	namespace Details {

		// Forward declarations from vccorlib DLL
		HRESULT STDMETHODCALLTYPE GetActivationFactory(_In_ Microsoft::WRL::Details::ModuleBase*, _In_ HSTRING, _Deref_out_::IActivationFactory**);
		bool STDMETHODCALLTYPE TerminateModule(_In_ Microsoft::WRL::Details::ModuleBase*);

	}
} // namespace Platform::Application::Details

// Override DllGetActivationFactory for external consumers of CxComponent.dll activatable classes
STDAPI DllGetActivationFactory(_In_ HSTRING activatibleClassId, _Deref_out_ IActivationFactory** ppFactory)
{
	auto classId = WindowsGetStringRawBuffer(activatibleClassId, nullptr);
	if (classId == L"CxComponent.StaticLibrary2.XamlMetaDataProvider"sv)
	{
		auto factory = static_cast<IUnknown*>(winrt_make_CxComponent_StaticLibrary2_XamlMetaDataProvider());
		if (!factory) return E_OUTOFMEMORY;
		*ppFactory = (IActivationFactory*)factory;
		return S_OK;
	}
	else if (classId == L"CxComponent.StaticLibrary2.Class2"sv)
	{
		auto factory = static_cast<IUnknown*>(winrt_make_CxComponent_StaticLibrary2_Class2());
		if (!factory) return E_OUTOFMEMORY;
		*ppFactory = (IActivationFactory*)factory;
		return S_OK;
	}
	return Platform::Details::GetActivationFactory(Microsoft::WRL::Details::ModuleBase::module_, activatibleClassId, ppFactory);
}

STDAPI DllCanUnloadNow()
{
	return Platform::Details::TerminateModule(Microsoft::WRL::Details::ModuleBase::module_) ? S_OK : S_FALSE;
}


// In a CX project, WinRT activation is performed by calling GetActivationFactoryByPCWSTR, 
// which can be hooked by providing an implementation of __winRT::__getActivationFactoryByPCWSTR.
// This is used in this example to show how a C++/WinRT implemented class from a static library
// can be used as a base class for an object implemented in C++/CX.

HRESULT __stdcall GetActivationFactoryByPCWSTR(void* str, ::Platform::Guid& riid, void** ppActivationFactory);
void __stdcall FlushFactoryCache();

namespace __winRT
{
	// Override __getActivationFactoryByPCWSTR for internal consumers of CxComponent.dll activatable classes
	long __stdcall __getActivationFactoryByPCWSTR(void* str, ::Platform::Guid& pGuid, void** ppActivationFactory)
	{
		if (static_cast<wchar_t*>(str) == L"CxComponent.StaticLibrary2.Class2"sv)
		{
			// Note: cppwinrt-generated factory returns default interface, IActivationFactory,
			// so need to QI to the requested factory.
			auto factory = static_cast<IUnknown*>(winrt_make_CxComponent_StaticLibrary2_Class2());
			if (!factory) return E_OUTOFMEMORY;
			auto hr = factory->QueryInterface(pGuid, ppActivationFactory);
			factory->Release();
			return hr;
		}
		return GetActivationFactoryByPCWSTR(str, pGuid, ppActivationFactory);
	}
}

namespace Platform
{
	void __stdcall Module::FlushFactoryCache()
	{
		::FlushFactoryCache();
	}
}
